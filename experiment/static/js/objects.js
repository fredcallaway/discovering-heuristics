// Generated by CoffeeScript 1.12.3

/**
 * Add an object to the scene.
 *
 * @param {string} name - the name of the object
 *
 * @param {Object} object - the object to be added. Should have
 * methods draw() and getBounds().
 *
 * @param {int} [index] - the sorting index where the object should be
 * inserted. This determines in what order the objects are drawn;
 * lower numbers will be drawn first. If not provided, then the object
 * will be added at the end of the list.
 *
 * @throws {Error} - if the object is already in the scene (you should
 * explicitly remove it first)
 */

/*jslint browser: true */

/*global _, check */

/**
 * Generic scene container for drawing on the canvas.
 * @constructor
 */
var Ball, Occluder, Scene, Timer, Trajectory, Wall, background;

Scene = function() {
  this.xmin = this.xmax = this.ymin = this.ymax = void 0;
  this.object_names = [];
  this.objects = {};
};


/**
 * A drawable object representing a wall.
 *
 * @constructor
 * @param {integer} x - the x-coordinate of the upper-left corner
 * @param {integer} y - the y-coordinate of the upper-left corner
 * @param {integer} width - the width of the wall
 * @param {integer} height - the height of the wall
 * @param {string} [color=rgb(0, 0, 0)] - the color of the wall,
 * represented as a rgb string. The default is black.
 */

Wall = function(x, y, width, height, color) {
  this.x = check('x', x);
  this.y = check('y', y);
  this.width = check('width', width);
  this.height = check('height', height);
  this.color = color || 'rgb(0, 0, 0)';
};

background = function(bounds, color) {
  var height, width, x, xmax, xmin, y, ymax, ymin;
  xmin = bounds.xmin, ymin = bounds.ymin, xmax = bounds.xmax, ymax = bounds.ymax;
  x = check('xmin', xmin);
  y = check('ymin', ymin);
  width = check('xmax', xmax) - xmin;
  height = check('ymax', ymax) - ymin;
  color = color || '#cccccc';
  return new Wall(x, y, width, height, color);
};


/**
 * A drawable object representing a gray, rectangular occluder.
 *
 * @constructor
 * @param {integer} xmin - the minimum x value to be occluded
 * @param {integer} xmax - the maximum x value to be occluded
 * @param {integer} ymin - the minimum y value to be occluded
 * @param {integer} ymax - the maximum y value to be occluded
 */

Occluder = function(bounds, color) {
  var xmax, xmin, ymax, ymin;
  xmin = bounds.xmin, ymin = bounds.ymin, xmax = bounds.xmax, ymax = bounds.ymax;
  this.x = check('xmin', xmin);
  this.y = check('ymin', ymin);
  this.width = check('xmax', xmax) - xmin;
  this.height = check('ymax', ymax) - ymin;
  this.color = color || '#cccccc';
  console.log('@color', this.color);
};


/**
 * A drawable object representing a ball.
 *
 * @constructor
 * @param {integer} x - the x-coordinate of the center of the ball
 * @param {integer} y - the y-coordinate of the center of the ball
 * @param {integer} radius - the radius of the ball
 * @param {string} [color=rgb(0, 0, 255)] - the color of the ball,
 * represented as a rgb string. The default is blue.
 */

Ball = function(x, y, radius, color) {
  this.x = check('x', x);
  this.y = check('y', y);
  this.radius = check('radius', radius);
  this.color = color || 'rgb(0, 0, 255)';
};


/*
 * A drawable object representing a countdown timer.
 *
 * @constructor
 * @param {integer} x - the x-coordinate of the center of the timer
 * @param {integer} y - the y-coordinate of the center of the timer
 * @param {integer} radius - the radius of the timer
 */

Timer = function(x, y, radius) {
  this.x = check('x', x);
  this.y = check('y', y);
  this.radius = check('radius', radius);
  this.percentFilled = 100;
};

Trajectory = function(t, x_offset, y_offset, index, color_bound) {
  this.t = check('trajectory', t);
  this.x_offset = check('x_offset', x_offset);
  this.y_offset = check('y_offset', y_offset);
  this.index = check('index', index);
  this.color_bound = color_bound;
};

Scene.prototype.addObject = function(name, object, index) {
  if (this.objects[name] !== void 0) {
    throw new Error('object \'' + name + '\' already exists in the scene');
  }
  this.objects[name] = object;
  if (index === void 0) {
    this.object_names.push(name);
  } else {
    this.object_names.splice(index, 0, name);
  }
  this.computeBounds();
};


/**
 * Remove an object from the scene.
 *
 * @param {string} name - the name of the object to remove
 * @throws {Error} - if the object is not in the scene
 */

Scene.prototype.removeObject = function(name) {
  if (this.objects[name] === void 0) {
    return;
  }
  delete this.objects[name];
  this.object_names = _.without(this.object_names, name);
  this.computeBounds();
};


/**
 * Computes the bounding box of the scene. This does not return
 * anything, but stores the computed values in this.xmin, this.xmax,
 * this.ymin, and this.ymax.
 */

Scene.prototype.computeBounds = function() {
  var bounds, i;
  if (this.object_names.length === 0) {
    this.xmin = void 0;
    this.xmax = void 0;
    this.ymin = void 0;
    this.ymax = void 0;
    return;
  }
  bounds = void 0;
  i = void 0;
  this.xmin = 100000;
  this.ymin = 100000;
  this.xmax = 0;
  this.ymax = 0;
  i = 0;
  while (i < this.object_names.length) {
    bounds = this.objects[this.object_names[i]].getBounds();
    this.xmin = Math.min(this.xmin, bounds[0]);
    this.xmax = Math.max(this.xmax, bounds[1]);
    this.ymin = Math.min(this.ymin, bounds[2]);
    this.ymax = Math.max(this.ymax, bounds[3]);
    i = i + 1;
  }
};


/**
 * Change the order position of an object such that it is the nth
 * object that is drawn, where n is specified by the index.
 *
 * @param {string} name - the name of the object
 * @param {integer} [index] - the index where the object should be
 * moved to. If not provided, then this defaults to the end of the
 * list.
 * @throws {Error} - if the object is not in the scene
 */

Scene.prototype.reorderObject = function(name, index) {
  if (this.objects[name] === void 0) {
    throw new Error('object \'' + name + '\' is not in the scene');
  }
  this.object_names = _.without(this.object_names, name);
  if (index === void 0) {
    this.object_names.push(name);
  } else {
    this.object_names.splice(index, 0, name);
  }
};


/**
 * Get the bounding box of the scene.
 * 
 * @returns {Array} length 4 array containing [xmin, xmax, ymin, ymax]
 */

Scene.prototype.getBounds = function() {
  return [this.xmin, this.xmax, this.ymin, this.ymax];
};


/**
 * Clears the drawing of the scene.
 *
 * @param {Object} ctx - the canvas drawing context
 */

Scene.prototype.clear = function(ctx) {
  ctx.clearRect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
};


/**
 * Draws the scene.
 *
 * @param {Object} ctx - the canvas drawing context
 */

Scene.prototype.draw = function(ctx) {
  var i;
  i = void 0;
  this.clear(ctx);
  i = 0;
  while (i < this.object_names.length) {
    this.objects[this.object_names[i]].draw(ctx);
    i = i + 1;
  }
};


/**
 * Get the bounds of the wall.
 *
 * @returns {Array} length 4 array containing [xmin, xmax, ymin, ymax]
 */

Wall.prototype.getBounds = function() {
  return [this.x, this.x + this.width, this.y, this.y + this.height];
};


/**
 * Draws the wall.
 *
 * @param {Object} ctx - the canvas drawing context
 */

Wall.prototype.draw = function(ctx) {
  ctx.fillStyle = this.color;
  ctx.fillRect(this.x, this.y, this.width, this.height);
};


/**
 * Get the bounds of the occluder.
 *
 * @returns {Array} length 4 array containing [xmin, xmax, ymin, ymax]
 */

Occluder.prototype.getBounds = function() {
  return [this.x, this.x + this.width, this.y, this.y + this.height];
};


/**
 * Draws the occluder.
 *
 * @param {Object} ctx - the canvas drawing context
 */

Occluder.prototype.draw = function(ctx) {
  ctx.fillStyle = this.color;
  ctx.fillRect(this.x, this.y, this.width, this.height);
};


/**
 * Get the (rectangular) bounds of the ball.
 *
 * @returns {Array} length 4 array containing [xmin, xmax, ymin, ymax]
 */

Ball.prototype.getBounds = function() {
  return [this.x - this.radius, this.x + this.radius, this.y - this.radius, this.y + this.radius];
};


/**
 * Draws the ball.
 *
 * @param {Object} ctx - the canvas drawing context
 */

Ball.prototype.draw = function(ctx) {
  ctx.fillStyle = this.color;
  ctx.beginPath();
  ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
  ctx.fill();
};


/**
 * Get the (rectangular) bounds of the timer.
 *
 * @returns {Array} length 4 array containing [xmin, xmax, ymin, ymax]
 */

Timer.prototype.getBounds = function() {
  return [this.x - this.radius, this.x + this.radius, this.y - this.radius, this.y + this.radius];
};


/**
 * Draws the timer. This will fill a percentage of a circle, depending
 * on the value of this.percentFilled (which starts at 100% by
 * default).
 *
 * @param {Object} ctx - the canvas drawing context
 */

Timer.prototype.draw = function(ctx) {
  var origin, pct;
  pct = Math.max(0, Math.min(this.percentFilled / 100, 1));
  origin = -Math.PI / 2;
  ctx.fillStyle = 'rgb(100, 100, 100)';
  if (this.percentFilled > 0) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, origin, origin - (Math.PI * 2 * pct), true);
    ctx.lineTo(this.x, this.y);
    ctx.fill();
  }
};

Trajectory.prototype.getBounds = function() {
  var i, xmax, xmin, ymax, ymin;
  xmin = void 0;
  xmax = void 0;
  ymin = void 0;
  ymax = void 0;
  i = void 0;
  xmin = this.t[0][0];
  xmax = this.t[0][1];
  ymin = this.t[0][0];
  ymax = this.t[0][1];
  i = 1;
  while (i <= this.index) {
    if (this.t[i][0] < xmin) {
      xmin = this.t[i][0];
    }
    if (this.t[i][1] < ymin) {
      ymin = this.t[i][1];
    }
    if (this.t[i][0] > xmax) {
      xmax = this.t[i][0];
    }
    if (this.t[i][1] > ymax) {
      ymax = this.t[i][1];
    }
    i = i + 1;
  }
  return [xmin + this.x_offset, xmax + this.x_offset, ymin + this.y_offset, ymax + this.y_offset];
};

Trajectory.prototype.draw = function(ctx) {
  var c, cb, i;
  i = void 0;
  c = void 0;
  cb = void 0;
  cb = this.color_bound || this.index - 1;
  if (this.index > 1 && this.index < this.t.length) {
    i = 0;
    while (i < this.index) {
      if (cb - i > 20) {
        c = 200;
      } else {
        c = (cb - i) * 10;
      }
      c /= 2;
      ctx.beginPath();
      ctx.strokeStyle = 'rgb(' + c + ', ' + c + ', ' + c + ')';
      ctx.moveTo(this.t[i][0] + this.x_offset, this.t[i][1] + this.y_offset);
      ctx.lineTo(this.t[i + 1][0] + this.x_offset, this.t[i + 1][1] + this.y_offset);
      ctx.stroke();
      i = i + 1;
    }
  }
};
