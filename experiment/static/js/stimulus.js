// Generated by CoffeeScript 1.12.3

/**
 * Initialize the stimulus.
 */

/**
 * A generic stimulus base class. This creates the scene from the
 * given config, and handles animating the scene. In general, you
 * should not use Stimulus directory but subclass it. Stimulus only
 * gives the generic skeleton of how a stimulus should be created.
 *
 * @constructor
 * @param {Object} config - the configuration for the stimulus. This
 * should include information about things like the width of the
 * walls, the ball radius, etc. See jsonstruct.txt for details.
 */
var Stimulus;

Stimulus = function(config) {
  window.stim = this;
  if (!config) {
    return;
  }
  this.width = check('width', config.Dims[0]);
  this.height = check('height', config.Dims[1]);
  this.wall_width = check('wall width', config.WallWid);
  this.ball_radius = check('ball radius', config.BallRad);
  this.ball_path = check('ball path', config.ObsPath);
  this.ball_path_extra = void 0;
  this.ball_trajectory = void 0;
  this.draw_trajectory = config.draw_trajectory;
  this.layouts = check('layouts', config.Layouts);
  this.current_layout = void 0;
  this.animator = {
    'timer': void 0,
    't': void 0,
    'onFinish': void 0
  };
  this.drawer = {
    'timer': void 0
  };
  this.countdown = {
    'timer': void 0,
    'start_time': void 0,
    'length': void 0,
    'onFinish': void 0
  };
  this.metadata = {
    'distance': check('distance', config.Distance),
    'num_bounces': check('num bounces', config.Bounces),
    'fps': check('fps', config.FPS)
  };
  this.scene = void 0;
  this.inner_bounds = void 0;
  this.canvas = void 0;
  this.ctx = void 0;
};

Stimulus.prototype.init = function(canvas) {
  this.scene = new Scene;
  this.scene.addObject('left_border', new Wall(0, 0, this.wall_width, this.height + 2 * this.wall_width));
  this.scene.addObject('right_border', new Wall(this.width + this.wall_width, 0, this.wall_width, this.height + 2 * this.wall_width));
  this.scene.addObject('top_border', new Wall(0, 0, this.width + this.wall_width, this.wall_width));
  this.scene.addObject('bottom_border', new Wall(0, this.height + this.wall_width, this.width + 2 * this.wall_width, this.wall_width));
  this.inner_bounds = {
    'xmin': this.scene.objects.left_border.getBounds()[1],
    'ymin': this.scene.objects.top_border.getBounds()[3],
    'xmax': this.scene.objects.right_border.getBounds()[0],
    'ymax': this.scene.objects.bottom_border.getBounds()[2]
  };
  this.canvas = canvas;
  this.canvas.attr('width', this.width + this.wall_width * 2);
  this.canvas.attr('height', this.height + this.wall_width * 2);
  this.ctx = this.canvas[0].getContext('2d');
};


/**
 * Destroy the stimulus. This includes completely removing everything
 * from the scene, and removing width and height attributes from the
 * canvas.
 */

Stimulus.prototype.destroy = function() {
  this.clearLayout();
  while (this.scene.object_names.length > 0) {
    this.scene.removeObject(this.scene.object_names[0]);
  }
  this.scene = void 0;
  this.inner_bounds = void 0;
  this.canvas.removeAttr('width');
  this.canvas.removeAttr('height');
  this.canvas = void 0;
  this.ctx = void 0;
};


/**
 * Loads the particular scene layout. This includes setting the ball
 * trajector, and creating the ball. Any other scene loading must be
 * handled by a subclass method.
 *
 * @param {string} layout_name - the name of the layout to load, which
 * should be a key in the this.layouts object.
 * @param {string} animation - the type of animation to play; can be
 * one of "stimulus" (only the stimulus presentation), "feedback"
 * (only the feedback, after the stimulus has been presented), or
 * "full" (both the stimulus presentation and the feedback).
 */

Stimulus.prototype.loadLayout = function(layout_name, animation) {
  var layout, x, y;
  layout = void 0;
  x = void 0;
  y = void 0;
  check('layout_name', layout_name);
  check('animation', animation);
  layout = check('layout \'' + layout_name + '\'', this.layouts[layout_name]);
  this.current_layout = [layout_name, animation];
  this.ball_path_extra = check('end path', layout.EndPath);
  if (animation === 'stimulus') {
    this.ball_trajectory = this.ball_path;
  } else if (animation === 'feedback') {
    this.ball_trajectory = this.ball_path_extra;
  } else if (animation === 'full') {
    this.ball_trajectory = this.ball_path;
  } else {
    throw new Error('invalid animation type: ' + animation);
  }
  x = this.ball_trajectory[0][0] + this.inner_bounds.xmin;
  y = this.ball_trajectory[0][1] + this.inner_bounds.ymin;
  if (this.scene.objects.trajectory !== void 0) {
    this.scene.removeObject('trajectory');
  }
  if (this.scene.objects.trajectory_init !== void 0) {
    this.scene.removeObject('trajectory_init');
  }
  if (this.draw_trajectory) {
    this.scene.addObject('trajectory', new Trajectory(this.ball_trajectory, this.inner_bounds.xmin, this.inner_bounds.ymin, 0));
    if (animation === 'feedback') {
      this.scene.addObject('trajectory_init', new Trajectory(this.ball_path, this.inner_bounds.xmin, this.inner_bounds.ymin, this.ball_path.length - 1, this.ball_path.length + this.ball_path_extra.length - 1));
    }
  }
  this.scene.removeObject('ball');
  this.scene.addObject('ball', new Ball(x, y, this.ball_radius));
};


/**
 * Unloads the layout that was loaded in by this.loadLayout. This will
 * also stop the animation, if it is currently running.
 */

Stimulus.prototype.clearLayout = function() {
  this.clearAnimation();
  this.clearCountdown();
  this.hideOccluder();
  this.animator.t = void 0;
  this.current_layout = void 0;
  this.ball_path_extra = void 0;
  this.ball_trajectory = void 0;
  this.scene.removeObject('ball');
  this.scene.removeObject('trajectory');
  this.scene.removeObject('trajectory_init');
  this.stopDrawing();
};


/**
 * Moves the ball to the appropriate position for a given frame.
 * @param [int] frame - the index of the frame to display
 */

Stimulus.prototype.showFrame = function(frame) {
  this.scene.objects.ball.x = this.ball_trajectory[frame][0] + this.inner_bounds.xmin;
  this.scene.objects.ball.y = this.ball_trajectory[frame][1] + this.inner_bounds.ymin;
  if (this.scene.objects.trajectory !== void 0) {
    this.scene.objects.trajectory.index = frame;
  }
};


/**
 * Sets up the next frame of the stimulus' animation, based on the
 * value of this.animator.t (currently, a frame just constitutes the
 * position of the ball). If there are no more frames left, then an
 * optional callback is excuted (specified when this.animate() was
 * called), and the animation inteval is cleared.
 */

Stimulus.prototype.showNextFrame = function() {
  var f;
  if (this.animator.t < this.ball_trajectory.length) {
    this.showFrame(this.animator.t);
    this.animator.t = this.animator.t + 1;
  } else {
    this.stopAnimation();
    if (this.animator.onFinish) {
      f = this.animator.onFinish;
      this.animator.onFinish = void 0;
      f();
    }
  }
};


/**
 * Starts the stimulus' ball animation. The animation will be played
 * back at the rate specified in this.metadata.fps.
 *
 * @param {function} [callback] - an optional callback to be executed
 * when the animation is complete. This will NOT be called if the
 * animation is stopped prematurely.
 */

Stimulus.prototype.animate = function(callback) {
  var that;
  this.clearAnimation();
  this.animator.onFinish = callback;
  this.animator.t = 0;
  that = this;
  this.animator.timer = window.setInterval((function() {
    that.showNextFrame();
  }), 1000 / this.metadata.fps);
};


/**
 * Stops the animation, if it is currently playing, but does not reset
 * it (for that, use clearAnimation()).
 */

Stimulus.prototype.stopAnimation = function() {
  if (this.animator.timer) {
    window.clearInterval(this.animator.timer);
    this.animator.timer = void 0;
  }
};


/**
 * Completely clears the animation. This means stopping it, if it is
 * currently playing, and unsetting all the relevant variables.
 */

Stimulus.prototype.clearAnimation = function() {
  this.stopAnimation();
  this.animator.t = void 0;
  this.animator.timer = void 0;
  this.animator.onFinish = void 0;
};


/**
 * Add an occluder to the scene.
 */

Stimulus.prototype.showOccluder = function() {
  this.scene.addObject('occluder', new Occluder(this.wall_left + this.inner_bounds.xmin + this.wall_width, this.inner_bounds.xmax, this.inner_bounds.ymin, this.inner_bounds.ymax));
  if (this.scene.objects.trajectory !== void 0) {
    this.scene.reorderObject('trajectory');
  }
};


/**
 * Remove the occluder from the scene.
 */

Stimulus.prototype.hideOccluder = function() {
  if (this.scene.objects.occluder !== void 0) {
    this.scene.removeObject('occluder');
    this.scene.reorderObject('ball');
  }
};


/**
 * Update the countdown timer. This computes the current time, figures
 * what percentage of the total time has passed, and updates the
 * countdown object.
 */

Stimulus.prototype.updateCountdown = function() {
  var f, pct;
  f = void 0;
  pct = void 0;
  pct = 100 * (Date.now() - this.countdown.start_time) / this.countdown.length;
  if (pct < 100) {
    this.scene.objects.countdown.percentFilled = 100 - pct;
  } else {
    this.scene.objects.countdown.percentFilled = 0;
    this.stopCountdown();
    if (this.countdown.onFinish) {
      f = this.countdown.onFinish;
      this.countdown.onFinish = void 0;
      f();
    }
  }
};


/**
 * Begin the countdown timer. This will stop and reset the timer if it
 * has already been started before.
 *
 * @param {int} length - the length of time in milliseconds that the
 * countdown should run for
 * @param {function} [callback] - a function to call when the timer
 * has finished counting down. This will NOT be called if the timer is
 * stopped prematurely.
 */

Stimulus.prototype.startCountdown = function(length, callback) {
  var that, x, y;
  x = void 0;
  y = void 0;
  that = void 0;
  this.clearCountdown();
  x = this.inner_bounds.xmin + 30;
  y = this.inner_bounds.ymin + 30;
  this.scene.addObject('countdown', new Timer(x, y, 15));
  this.countdown.start_time = Date.now();
  this.countdown.length = check('countdown length', length);
  this.countdown.onFinish = callback;
  that = this;
  this.countdown.timer = window.setInterval((function() {
    that.updateCountdown();
  }), 10);
};


/**
 * Stops the countdown timer if it is running, but does not reset it
 * (for that, use clearCountdown()).
 */

Stimulus.prototype.stopCountdown = function() {
  if (this.countdown.timer) {
    window.clearInterval(this.countdown.timer);
    this.countdown.timer = void 0;
  }
};


/**
 * Completely clears the countdown timer if it is running, which
 * includes unsetting the relevant variables.
 */

Stimulus.prototype.clearCountdown = function() {
  this.stopCountdown();
  if (this.scene.objects.countdown !== void 0) {
    this.scene.removeObject('countdown');
  }
  this.countdown.timer = void 0;
  this.countdown.start_time = void 0;
  this.countdown.length = void 0;
  this.countdown.onFinish = void 0;
};


/**
 * Begins the main drawing loop. This calls a function (at a rate
 * specified by this.metadata.fps) which redraws the canvas each
 * time. The canvas should ONLY ever be redrawn using this drawing
 * loop. If you don't need an entire drawing loop, then you can use
 * this.drawOnce() to redraw the canvas exactly once.
 */

Stimulus.prototype.startDrawing = function() {
  if (this.drawer.timer) {
    throw new Error('drawing has already been started');
  }
  this.drawOnce();
  return this.drawer.timer = window.setInterval(((function(_this) {
    return function() {
      return _this.drawOnce();
    };
  })(this)), 1000 / this.metadata.fps);
};


/**
 * Stops the main drawing loop. After stopping the drawing timer, it
 * will draw the scene again once to make sure that the most recent
 * changes to the scene are displayed.
 */

Stimulus.prototype.stopDrawing = function() {
  this.drawOnce();
  if (this.drawer.timer) {
    window.clearInterval(this.drawer.timer);
    return this.drawer.timer = void 0;
  }
};


/**
 * Draws the scene exactly once. In general, this function should not
 * be used; you should start the drawing loop with this.startDrawing()
 * instead. You should only use this function when you really just
 * need to draw the scene once; any type of animation should be shown
 * using the loop.
 */

Stimulus.prototype.drawOnce = function() {
  this.scene.draw(this.ctx);
};
